# 第三章 管线一览
## 本章我们会学到什么

- OpenGL管线的每个阶段做什么的
- 如果连接着色器和固定功能管线阶段
- 如果创建一个程式同时使用图形管线的每个阶段

在本章我们将从始至终过一遍OpenGL管线，对每个阶段进行考察，包括固定功能块和可编程着色器块。我们已经对顶点着色器和片段着色器有了初步的大致了解。然而，我们创建的应用只能简单地在固定位置绘制一个三角形。如果我们想要使用OpenGL渲染任何有趣的东西，我们必须继续学习管线以及我们用它所能做的所有事。本章介绍管线的每个部分，将它们彼此联接并为每个阶段提供一个着色器示例。

## 传递数据给顶点着色器
顶点着色器是OpenGL管线中第一个*可编程(programmable)*的阶段并且是图形管线中唯一必须的阶段。不过，在顶点着色器运行之前，一个称为*顶点获取(vertex fetching)*或*顶点拉取(vertex pulling)*的固定功能阶段会运行。它自动为顶点着色器提供输入数据。

## 顶点属性
在GLSL中供着色器获取输入或输出数据的机制是使用**in**和**out**存储标识符声明全局变量。在第二章“我们的第一个OpenGL程式”中我们简要介绍了**out**标识符，在清单2.4中用它从片段着色器输出一个颜色。在OpenGL管线的开端，我们使用**in**关键字为顶点着色器输入数据。在阶段之间，使用**in**和**out**组成导管在着色器之间传递数据。我们马上就会知道这个。现在，考虑顶点着色器的输入以及如果我们使用**in**存储标识符声明一个变量发生了什么。这个标识符标明这个变量是顶点着色器的输入，意味着这个变量是OpenGL图形管线的重要输入。这个变量在固定功能的顶点获取阶段被自动填充。这个变量即为*顶点属性(vertex attribute)*。

顶点属性是顶点数据引入OpenGL管线的手段。要声明一个顶点属性，我们在顶点着色器中使用**in**存储标识符声明一个全局变量即可。如清单3.1所示，我们将**offset**变量声明为一个输入的顶点属性。

清单3.1 声明一个顶点属性:

    #version 450 core
    
    // 'offset' is an input vertex attribute
    layout (location = 0) in vec4 offset;
    
    void main(void)
    {
        const vec4 vertices[3] = vec4[3](vec4(0.25, -0.25, 0.5, 1.0),
                                         vec4(-0.25, -0.25, 0.5, 1.0), 
                                         vec4(0.25, 0.25, 0.5, 1.0));

        // Add 'offset' to our hard-coded vertex position
        gl_Position = vertices[gl_VertexID] + offset;
    }
    
在清单3.1中，我添加**offset**变量作为顶点着色器的输入。因为它是管线第一个着色器的输入，故它会在顶点获取阶段被自动填充。我们可以用众多顶点属性相关的函数(`glVertexAttrib*()`)来指示OpenGL在顶点获取阶段为相关变量填充何值。我们将会用到的**glVertexAttrib4fv()**的原型如下:

    void glVertexAttrib4fv(GLuint index, const GLfloat* v);
    
参数`index`用来索引指定的属性，`v`是要放入属性的新数据的指针。你或许已注意到声明`offset`属性中的代码`layout (location = 0)`。这是一个*布局指示符(layout qualifier)*，我们用它来设置指定的顶点属性的*位置(location)*为0。这个位置的值就是我们通过`index`来传递进行这个属性引用的值。

每次我们调用任何一个`glVertexAttrib*()`函数都会更新传递给顶点着色器的顶点属性的值。我们可以使用这个方法来给我们的三角形加上动画。清单3.2展示了一个更新版本的渲染函数，它在每一帧都会更新`offset`的值。

清单3.2 更新一个顶点属性:

    // Our rendering function
    virtual void render(double currentTime)
    {
        const GLfloat color[] = { (float)sin(currentTime) * 0.5f + 0.5f, 
                                  (float)cos(currentTime) * 0.5f + 0.5f,
                                  0.0f, 1.0f };
        glClearBufferfv(GL_COLOR, 0, color);
        
        // Use the program object we created earlier for rendering
        glUseProgram(rendering_program);
        
        GLfloat attrib[] = { (float)sin(currentTime) * 0.5,
                             (float)cos(currentTime) * 0.6f,
                             0.0f, 0.0f };
        // Update the value of input attribute 0
        glVertexAttrib4fv(0, attrib);
        
        // Draw one triangle
        glDrawArrays(GL_TRIANGLES, 0, 3);
    }
    
运行清单3.2中的代码，我们会看到三角形在窗体中以一个圆滑的椭圆形路径运动。(译者注: 译者的仓库sb7examples中相应工程为chapter3/update_vertex_attribute)
