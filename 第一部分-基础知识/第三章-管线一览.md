# 第三章 管线一览
## 本章我们会学到什么

- OpenGL管线的每个阶段做什么的
- 如果连接着色器和固定功能管线阶段
- 如果创建一个程式同时使用图形管线的每个阶段

在本章我们将从始至终过一遍OpenGL管线，对每个阶段进行考察，包括固定功能块和可编程着色器块。我们已经对顶点着色器和片段着色器有了初步的大致了解。然而，我们创建的应用只能简单地在固定位置绘制一个三角形。如果我们想要使用OpenGL渲染任何有趣的东西，我们必须继续学习管线以及我们用它所能做的所有事。本章介绍管线的每个部分，将它们彼此联接并为每个阶段提供一个着色器示例。

## 传递数据给顶点着色器
顶点着色器是OpenGL管线中第一个*可编程(programmable)*的阶段并且是图形管线中唯一必须的阶段。不过，在顶点着色器运行之前，一个称为*顶点获取(vertex fetching)*或*顶点拉取(vertex pulling)*的固定功能阶段会运行。它自动为顶点着色器提供输入数据。

## 顶点属性
在GLSL中供着色器获取输入或输出数据的机制是使用**in**和**out**存储标识符声明全局变量。在第二章“我们的第一个OpenGL程式”中我们简要介绍了**out**标识符，在清单2.4中用它从片段着色器输出一个颜色。在OpenGL管线的开端，我们使用**in**关键字为顶点着色器输入数据。在阶段之间，使用**in**和**out**组成导管在着色器之间传递数据。我们马上就会知道这个。现在，考虑顶点着色器的输入以及如果我们使用**in**存储标识符声明一个变量发生了什么。这个标识符标明这个变量是顶点着色器的输入，意味着这个变量是OpenGL图形管线的重要输入。这个变量在固定功能的顶点获取阶段被自动填充。这个变量即为*顶点属性(vertex attribute)*。

顶点属性是顶点数据引入OpenGL管线的手段。要声明一个顶点属性，我们在顶点着色器中使用**in**存储标识符声明一个全局变量即可。如清单3.1所示，我们将**offset**变量声明为一个输入的顶点属性。

清单3.1 声明一个顶点属性:

    #version 450 core
    
    // 'offset' is an input vertex attribute
    layout (location = 0) in vec4 offset;
    
    void main(void)
    {
        const vec4 vertices[3] = vec4[3](vec4(0.25, -0.25, 0.5, 1.0),
                                         vec4(-0.25, -0.25, 0.5, 1.0), 
                                         vec4(0.25, 0.25, 0.5, 1.0));

        // Add 'offset' to our hard-coded vertex position
        gl_Position = vertices[gl_VertexID] + offset;
    }
    
在清单3.1中，我添加**offset**变量作为顶点着色器的输入。因为它是管线第一个着色器的输入，故它会在顶点获取阶段被自动填充。我们可以用众多顶点属性相关的函数(`glVertexAttrib*()`)来指示OpenGL在顶点获取阶段为相关变量填充何值。我们将会用到的**glVertexAttrib4fv()**的原型如下:

    void glVertexAttrib4fv(GLuint index, const GLfloat* v);
    
参数`index`用来索引指定的属性，`v`是要放入属性的新数据的指针。你或许已注意到声明`offset`属性中的代码`layout (location = 0)`。这是一个*布局指示符(layout qualifier)*，我们用它来设置指定的顶点属性的*位置(location)*为0。这个位置的值就是我们通过`index`来传递进行这个属性引用的值。

每次我们调用任何一个`glVertexAttrib*()`函数都会更新传递给顶点着色器的顶点属性的值。我们可以使用这个方法来给我们的三角形加上动画。清单3.2展示了一个更新版本的渲染函数，它在每一帧都会更新`offset`的值。

清单3.2 更新一个顶点属性:

    // Our rendering function
    virtual void render(double currentTime)
    {
        const GLfloat color[] = { (float)sin(currentTime) * 0.5f + 0.5f, 
                                  (float)cos(currentTime) * 0.5f + 0.5f,
                                  0.0f, 1.0f };
        glClearBufferfv(GL_COLOR, 0, color);
        
        // Use the program object we created earlier for rendering
        glUseProgram(rendering_program);
        
        GLfloat attrib[] = { (float)sin(currentTime) * 0.5,
                             (float)cos(currentTime) * 0.6f,
                             0.0f, 0.0f };
        // Update the value of input attribute 0
        glVertexAttrib4fv(0, attrib);
        
        // Draw one triangle
        glDrawArrays(GL_TRIANGLES, 0, 3);
    }
    
运行清单3.2中的代码，我们会看到三角形在窗体中以一个圆滑的椭圆形路径运动。(译者注: 译者的仓库sb7examples中相应工程为chapter3/update_vertex_attribute)

## 在着色器阶段间传递数据
目前为止我们已经看到了如何通过使用**in**关键字创建一个顶点属性来传递数据给顶点着色器，如何通过读写诸如`gl_VertexID`、`gl_Position`等内置变量和固定功能块交流，如何使用**out**关键字从片段着色器输出数据。不过，我们同样可以使用**in**和**out**关键字在着色器阶段之间传递我们的数据。一如我们在片段着色器中使用**out**关键字来创建输出颜色值的变量一样，我们也能在顶点着色器中使用**out**关键字创建一个输出变量。在一个着色器中写入到一个输出变量的任何内容都会传递给下一个着色器阶段中以**in**声明的同名变量。比如，如果我们在顶点着色器中使用**out**关键字声明一个叫`vs_color`的变量，接下来在片段着色器阶段这个变量就会匹配到一个用**in**关键字声明的名为`vs_color`的变量上(假设它们间没有其他的阶段)。

如果将我们简单的顶点着色器修改为清单3.3，包含一个`vs_color`的输出变量，并相应将我们简单的片段着色器修改为清单3.4，包含一个`vs_color`的输入变量，我们便能将一个值从顶点着色器传给片段着色器。然后，相比之前输出一个固定的颜色值，现在这个片段着色器可以将顶点着色器传给它的颜色值输出。

清单3.3 带一个输出变量的顶点着色器:

    #version 450 core
    
    // 'offset' and 'colour' are input vertex attributes
    layout (location = 0) in vec4 offset;
    layout (location = 1) in vec4 color;
    
    // 'vs_color' is an output that will be sent to the next shader stage
    out vec4 vs_color;

    void main(void)
    {
        const vec4 vertices[3] = vec4[3](vec4(0.25, -0.25, 0.5, 1.0), 
                                         vec4(-0.25, -0.25, 0.5, 1.0),
                                         vec4(0.25, 0.25, 0.5, 1.0));
                                         
        // Add 'offset' to our hard-coded vertex position
        gl_Position = vertices[gl_VertexID] + offset;
        
        // Output a fixed value for vs_color
        vs_color = color;
    }

从清单3.3可以看到，我们为这个顶点着色器声明了第二个输入变量: `color`(这次location为1)，并将它的值写入到输出变量`vs_color`。然后这个值为清单3.4的片段着色器所用，写入到帧缓冲区。这使得我们可以把一个通过`glVertexAttrib*`设置的顶点属性的颜色值一路从顶点着色器传入片段着色器，然后写到帧缓冲区。结果就是我们可以绘制他色的三角形了。

清单3.4 带有一个输入变量的片段着色器:

    #version 450 core
    
    // Input from the vertex shader
    in vec4 vs_color;
    
    // Output to the framebuffer
    out vec4 color;
    
    void main(void)
    {
        // Simply assign the colour we were given by the vertex shader to our output
        color = vs_color;
    }
    
译者注: 译者的sb7examples中相应工程为chapter3/different_colored_triangle。

### 数据块接口(Interface Blocks)
一次声明一个接口变量用来在着色器阶段间传递数据可能是最简单的方法。然而，在大多数工业用的应用的，我们会想在着色器阶段间传递成堆的数据，这些可能包括数组、结构体以及其他复杂排列的变量。为达此目的，我们可以将好些个变量组成一个*数据块接口(interface block)*。数据块接口的声明和C中结构体的声明很像，除了数据块接口依据它是从着色器输入数据还是输出数据而使用**in**或者**out**关键字声明。示一例如清单3.5。

清单3.5 带一个输出数据块接口的顶点着色器:

    #version 450 core
    
    // 'offset' is an input vertex attribute
    
    layout (location = 0) in vec4 offset;
    layout (location = 1) in vec4 color;
    
    // Declare VS_OUT as an output interface block
    out VS_OUT
    {
        vec4 colour;    // Send color to the next stage
    } vs_out;
    
    void main(void)
    {
        const vec4 vertices[3] = vec4[3](vec4(0.25, -0.25, 0.5, 1.0),
                                         vec4(-0.25, -0.25, 0.5, 1.0),
                                         vec4(0.25, 0.25, 0.5, 1.0));
                                         
        // Add 'offset' to our hard-coded vertex position
        gl_Position = vertices[gl_VertexID] + offset;
        
        // Output a fixed value for vs_color
        vs_out.color = color;
    }
    
值得注意的是清单3.5中的数据块接口同时有一个块名称(大写的`VS_OUT`)和一个实例名称(小写的`vs_out`)。数据块接口在着色器阶段间通过块名称匹配(本例中为`VS_OUT`)但在着色器中则是用实例名称引用(本例中为`vs_out`)。将我们的片段着色器修改为清单3.6来使用这个数据块接口。

清单3.6 带一个输入数据块接口的片段着色器:

    #version 450 core
    
    // Declare VS_OUT as an input interface block
    in VS_OUT
    {
        vec4 colour;    // Send color to the stage
    } fs_in;
    
    // Output to the framebuffer
    out vec4 color;
    
    void main(void)
    {
        // Simply assign the color we were given by the vertex shader to our output
        color = fs_in.color;
    }
    
译者注: 译者的sb7examples中相应工程为chapter3/interface_block_triangle。

通过块名称匹配但允许块实例在每个着色器阶段有不同的名称，这种设定出于两方面的考量。第一，允许不同着色器阶段使用不同的名称进行引用，可以避免一些混乱，比如要在片段着色器中使用`vs_out`。第二，当我们纵横于一些着色器阶段时，比如顶点着色器、细分着色器或者几何着色器阶段(我们马上就会看到了)，这样使得接口从单个条目变成数组。值得注意的是数据块接口只能用于着色器阶段到着色器阶段的数据传递--我们不能用它将顶点着色器的输入或者片段着色器的输出组建成群。

## 细分曲面(Tessellation)
细分曲面是将高阶图元(在OpenGL中常称为*碎片(patch)*)降解为很多更小的、更简单的图元，诸如三角形之后进行渲染。OpenGL包含一个固定功能的、可配置的细分曲面引擎，它可以将四边形、三角形以及线段降解为可能很多的可被常规光栅硬件使用的更小的点、线段或者三角形。从逻辑上来说，细分曲面阶段由三部分组成：细分曲面控制着色器，固定功能细分曲面引擎以及细分曲面运算着色器，在OpenGL管线中细分曲面阶段直接跟在顶点着色阶段之后。

### 细分曲面控制着色器(Tessellation Control Shaders)
细分曲面三个阶段的第一阶段为细分曲面控制着色器(TCS;有时简称为控制着色器)。这个着色器从顶点着色器接收输入并主要负责两件事：1.确定要发送给细分曲面引擎的细分曲面等级。2.生成细分曲面运行之后要发送给细分曲面运算着色器的数据。

在OpenGL中，细分曲面通过将被称为*碎片(patches)*的高阶表面降解为点、线段或者三角形而进行正常工作。每一个碎片都由一定数目的*控制点(control points)*组成。每个碎片的控制点数目都是可配置的，通过调用**glPatchParameteri()**即可设置，同时将`pname`设置为`GL_PATCH_VERTICES`以及`value`设置为构成每个碎片的控制点的数目。**glPatchParameteri()**的原型如:

    void glPatchParameteri(GLenum pname, GLint value);
    
缺省情况下，每个碎片的控制点数目是3。所以，如果这就是我们想要的(一如我们接下来的示例)，我们完全可以不调用这个函数。用来构成一个碎片的最高控制点数目是由实现定义的，但保证至少为32。

当细分曲面开始时，顶点着色器会针对每一个控制点运行一次，不过细分曲面控制着色器根据控制点的群组按批次运行，每个批次的大小和每个碎片的顶点数一样。意即，顶点被当做控制点而且顶点着色器的输出结果被成批送往细分曲面控制着色器当做输入。每个碎片的控制点数目是可以改变的所以细分曲面控制着色器输出的控制点数目可以和它消耗的控制点数目不同。控制着色器产生的控制点数目在控制着色器的源代码中使用一个输出布局标识符进行设置。这样的布局标识符看起来像这样:

    layout (vertices = N) out;
    
这里的`N`即每个碎片的控制点数目。控制着色器有责任计算输出控制点的数目以及设置作为最终结果发送给固定功能细分曲面引擎的碎片的细分曲面因子。输出的细分曲面因子写入内置变量`gl_TessLevelInner`和`gl_TessLevelOuter`中，而其他任何在管线中传递的数据都正常地写入用户定义的输出变量(使用**out**关键字声明的或者特殊的内置`gl_out`数组)。

清单3.7展示了一个简单的细分曲面控制着色器。它用布局标识符`layout (vertices = 3) out;`设置输出的控制点数目为3(与缺省的输入控制点数目相同)，将它的输入拷贝到输出(使用内置变量**gl_in**和**gl_out**)，并设置内和外的细分曲面级别为5。更高的细分曲面级别会产生更密集的细分曲面输出，更低的级别会产生更粗糙的细分曲面输出。将细分曲面因子设置为0会导致整个碎片被丢弃。

内置变量`gl_InvocationID`被用作`gl_in`和`gl_out`数组的索引，从0开始算起。这个变量表示当前被调用的细分曲面控制着色器中被处理的碎片的控制点索引值。

清单3.7 我们的第一个细分曲面控制着色器:

    #version 450 core
    
    layout (vertices = 3) out;
    
    void main(void)
    {
        // Only if I am invocation 0 ...
        if (gl_InvocationID == 0)
        {
            gl_TessLevelInner[0] = 5.0;
            gl_TessLevelOuter[0] = 5.0;
            gl_TessLevelOuter[1] = 5.0;
            gl_TessLevelOuter[2] = 5.0;
        }
        // Everybody copies their input to their output
        gl_out[gl_InvocationID].gl_Position = 
            gl_in[gl_InvocationID].gl_Position;
    }

### 细分曲面引擎(The Tessellation Engine)
细分曲面引擎是OpenGL管线中的一个固定功能部分，它接收表示为碎片的高阶表面并将它们降解为更简单的图元，比如：点、线段或者三角形。在细分曲面引擎接收碎片之前，细分曲面控制着色器处理输入的控制点并设置细分曲面因子，然后用它们来降解这个碎片。细分曲面引擎生成输出图元之后，用以表示这些图元的顶点被细分曲面运算着色器所利用。细分曲面引擎有责任生成用以调用细分曲面运算着色器的参数，然后细分曲面运算着色器用这些参数转换作为最终结果的图元并将它们准备好光栅化。

### 细分曲面运算着色器(Tessellation Evaluation Shaders)
一旦固定功能细分曲面引擎运行后，它会产生一些输出顶点用来表示生成的图元。这些顶点会传递给细分曲面运算着色器。细分曲面运算着色器(TES;或者简称为运算着色器)会对细分曲面器生成的每个顶点运行一次。当细分曲面级别高时，细分曲面运算着色器将会运行很多次。为此，对于复杂的运算着色器和高细分曲面级别我们需要小心应付。

清单3.8展示了一个细分曲面运算着色器，它接受由清单3.7所示的控制着色器运行输出的顶点作为输入。在这个着色器开头是一个布局标识符，它设置了细分曲面模式。在本例中，我们选择模式为三角形。其他标识符`equal_spacing`和`cw`表明新的顶点生成时要是沿着细分的多边形边缘等距的并且生成的三角形的顶点环绕次序是顺时针的。我们会在第八章的“细分曲面”中对其他可能的选项进行更全面的介绍。

这个着色器的剩余部分如顶点着色器一样对`gl_Position`进行了赋值。它使用多个内置变量来计算`gl_Position`的值。第一个是`gl_TessCoord`，它是细分曲面器生成的顶点的质心坐标。第二个是`gl_in[]`结构体数组的成员`gl_Position`。`gl_in`匹配清单3.7中的细分曲面控制着色器写入的`gl_out`结构体。这个着色器主要实做了直通细分(pass-through tessellation)。意即，细分后输出的碎片与原始输入的三角形碎片形状一致。

清单3.8 我们的第一个细分曲面运算着色器:

    #version 450 core
    
    layout (triangles, equal_spacing, cw) in;
    
    void main(void)
    {
        gl_Position = (gl_TessCoord.x * gl_in[0].gl_Position + 
                       gl_TessCoord.y * gl_in[1].gl_Position + 
                       gl_TessCoord.z * gl_in[2].gl_Position);
    }
    
为了能看到细分曲面器的结果，我们需要指示OpenGL只绘制最终结果的三角形的轮廓。为达此目的，我们调用**glPolygonMode()**，它的原型为:

    void glPolygonMode(GLenum face, GLenum mode);

`face`参数指明我们想影响哪个类型的多边形。因为我们想要影响所有东西，故我们设置它为`GL_FRONT_AND_BACK`.`mode`表明我们想要如何渲染多边形。我们想要渲染为线框模式(即直线)，我们将这个参数设置为`GL_LINE`。其他模式我们很快就会解释的。我们的三角形示例在使用细分曲面以及清单3.7、清单3.8的着色器之后，渲染结果如图示3.1:

![figure3.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure3.1.png)

译者注: 译者的sb7examples中相应项目为chapter3/triangle_with_tessellation
