#第一章

# 简介

## 我们从这章能学到什么
- 什么是图形管线(Graphics Pipeline)以及OpenGL如何与它关联
- OpenGL的起源以及它如何演变成现在的模样
- 我们在全书中都会使用到的一些基本概念

OpenGL是一种接口，在我们的应用程序中可以用它来访问或者控制它所运行的设备的图形子系统。它所运行的设备可以从一个高端图形工作站到商用台式机、视频游戏主机甚至是一台智能手机。将这些设备的接口标准化到一个子系统可以增强移植性并且可以让软件开发者集中精力创作高品质的产品、制作更有有趣的内容以及关心他们的应用的整体效能，而不是陷于他们想要应用运行的平台的细节中。这些标准接口被称为Apllication Programming Interfaces(or APIs)，OpenGL是其中之一。这一章简要介绍OpenGL，描述它如何与底层的图形子系统关联，并且提供一些OpenGL的起源和演化历史。

## OpenGL和图形管线
生成一个高效能并且高容量的产品通常需要两个东西:可伸缩性(scalability)和并行性(parallelism)。在工厂中，这两个东西通过使用产品线(production lines)来达成。说来就是一个工人安装汽车的引擎，另一个安装车门，再另一个安装车轮。通过将产品的生产阶段进行重叠，每一个阶段都由一个专业的专家来专门完成这个任务，这样每一个阶段就变得更高效，然后整体生产效率就会提升。同样，通过在同一时间制作很多汽车，一个工厂可以让多个工人专门安装引擎，或者多个工人专门安装车轮，这样多辆汽车可以同时运作在产品线上，每辆车都处在完工的不同阶段。

计算机图形是同样的道理。我们的程序发送命令给OpenGL，然后OpenGL以一种尽可能高效的方式将命令发送给底层的图形硬件来产生预期的结果。在图形硬件上可能有很多命令排队等待执行(专业术语称为*in flight*)，其中一些命令可能是完成了一部分的。一个处于后续阶段的命令可以和一个处于前期阶段的命令被并发执行，这样它们的执行就重叠了。此外，计算机图形通常由很多非常相似的重复性任务组成(例如计算一个像素该为什么颜色)并且这些任务都彼此独立--意即，一个像素的颜色与另外一个像素的颜色没有任何关系。就好像一个车间可以同时制造多个汽车，所以OpenGL可以把你给他的工作拆解开然后用它的基础元素并行完成。通过组合管线(*pipelining*)和并行(*parallelism*)，现代图形处理器超乎想象的性能就被实现了。

OpenGL的目的是在我们的应用程序和底层的图形子系统中间提供一个抽象层(*abstraction layer*)，图形子系统通常是一个硬件加速器(由一个或多个自定义的高性能处理器和专用内存、显示输出等等构成)。这个抽象层可以使我们的应用程序不必知晓谁是制造的图形处理器(或者叫GPU - 图形处理单元)、它如何工作、它工作得好不好。当然我们的应用程序仍然可以获知这些信息，重要的是我们的应用程序不必如此。

作为一个设计原则，OpenGL必须在抽象层次的过高与过低之间取得平衡。一方面，它必须隐藏不同制造商的产品的区别(或者同一厂商的不同产品)和平台相关的特性，比如:显示屏分辨率、处理器架构、安装的操作系统等等。另一方面，它的抽象层次要低到可以让程序员获得底层硬件的访问权限并且充分利用它。如果OpenGL展现过高的抽象层次，这样它就可以很容易地用来创造符合它的样式的程序，但却很难使用到它未包含的图形硬件的高级特性。这种高层次抽象的样式有一些软件用到，如:游戏引擎--为了让基于它构建的游戏访问到新的图形硬件特性通常需要对引擎做出很大量的改变。如果抽象层次过低，应用程序需要关心它们所运行的平台的架构特性。低层次抽象在比如视频游戏主机中比较普遍，但这种抽象层次的图形库不能跨平台支持从移动手机到游戏的个人电脑甚至高性能专业的图形工作站。

随着技术的发展，计算机图形进行了越来越多的研究，最佳实践被开发出来，瓶颈和需求在变化，所以OpenGL也必须不断变化赶上时代。

大多数OpenGL实现都基于当前最先进的图形处理单元，可进行多个每秒万亿次浮点运算的运算能力、拥有好多G每秒吞吐量好几百G的内存、并且可以驱动多个几百万像素高频刷新的显示器。GPU也超级灵活，以至于可以处理跟图形完全不沾边的任务，比如:物理模拟、人工智能、甚至音频处理。

如今的GPU由大量的小型可编程处理器(被称为*shader cores*)组成，这些shader cores运行一种叫做(着色器)*shaders*的迷你程序。每个core有相对较低的吞吐量、在一个或多个时钟周期内处理shader的一条指令，并且一般缺少高级的特性，比如: 无序执行、分支预测、超标量技术等等。但每个GPU都可能包含从几十个到几千个这样的core，当它们聚集在一起时可以完成一个巨量的工作。图形系统被分解为多个阶段(stages)，每个阶段被用一个shader或者固定功能的函数、可能可配置的处理区块表示。图示1.1展示了一个精简的图形管线的概要。

!()[]
