# 第四章-3D图形中的数学
## 本章我们会学到什么
- 向量是什么，以及为什么我们要关心它们
- 矩阵是什么，以及为什么我们要关心它们
- 我们如何使用矩阵和向量来移动几何图形
- OpenGL约定和坐标空间是什么

到目前为止，我们已经学习了绘制点、线以及三角形，并写过几个简单的着色器传递硬编码的顶点数据。我们还未真正地渲染过3D的内容--在一本3D图形的书中这很奇怪！好吧，要把一系列形状转换到连贯的场景中，我们必须将它们互相以及和观察者安排好。在本章，我们将开始在坐标系统中移动形状和对象。在场景中摆放并设置对象的朝向对于每个3D图形程序员都是重要的能力。我们将会看到，在原点描述好对象的尺寸然后变换到目标位置实际上是很方便的。

## 本章是可怕的数学课吗？
在大多数3D图形编程的书中本章应该就是可怕的数学课了。然而，你可以放轻松，我们会采用比较适度的方式来描述这些原理，而不是干巴巴的文字。

我们的着色器会执行的第一个基础的数学操作就是坐标转换，归结起来就是乘上矩阵和向量。OpenGL程序员用来进行对象和坐标变换的关键是两个矩阵约定。为了让我们熟悉这些矩阵，本章在两种极端的计算机图形哲学中采取折中。一方面，我们可以警告你：“请在阅读本章前去复习下线性代数课本”。另一方面，我们可以欺骗你假装消除你的疑虑，你可以“学习3D图形而丝毫不用关心那些复杂的数学公式”。但我们不赞成任何一个阵营。

实际上，就算你没有非常出色地理解3D图形中的数学，你也可以继续前进，就好像我们每天都开车但不用了解机动车修理和内燃机引擎。但我们最好对车有足够的了解，我们需要常常换油，定期为油箱加油，当轮胎秃了要进行更换。这些知识会让你成为一个负责的、安全的机动车主。如果你像成为一个负责的、有能力的OpenGL程序员，同理。你至少需要懂得基础这样你可以知道什么可以做以及哪个工具最适合工作。如果你是个初学者，你会发现通过一些实践，矩阵数学和向量会逐渐变得易于理解，而且你也会开发出更好的直觉和强大的能力以全面利用本章所介绍的概念。

所以就算你还没有在脑海中将两个矩阵相乘的能力，你也需要知道矩阵是什么，它们如何成为OpenGL 3D魔法的服务手段。不过在我们掸去《线性代数》课本的尘土之前，不要怕：本书的`sb7`库有一个称为`vmath`的组件，它包含有很多有用的类和函数，可以用来表示以及操作向量和矩阵。它们可以直接和OpenGL一起使用，在语法和外观上与GLSL(我们用来编写着色器的语言)神似。所有，我们不需要自己全部来做矩阵和向量的操作，不过知道它们是什么以及如何应用它们仍然是大有裨益的。

## 3D图形数学的一个快速课程
首先，在这里我们不会假设我们会涉及到所有重要的东西。实际上，我们甚至不会涉及到应该知道的所有东西。在本章，我们仅仅会涉及到真正需要知道的东西。如果你已是一个数学能手，你应该立刻跳到后面关于标准3D变换的章节。不仅仅是你已经知道我们会涉及到什么，而且大多数数学迷会觉得不愉快，我们不会给他们喜爱的齐次坐标空间(homogeneous coordinate spaces)功能太多的发挥空间。想象那些真实的TV秀，我们现在必须从一个充满鳄鱼的沼泽中逃出去。知道多少真正需要的3D数学才能生存下来？那就是接下来两节会讲到的--3D数学生存技巧。鳄鱼才不会关心我们是不是真的知道什么是齐次坐标空间。

### 向量(Vector)
OpenGL的主要输入为顶点，顶点有一些属性通常包括位置。最基本的，这是在xyz坐标空间的位置，而且一个给定的位置在这个坐标空间中有且只有一个xyz三元组。一个xyz三元组可以表示为一个向量(实际上，对于纯粹的数学之心来说，一个位置其实也是一个向量--看，我们丢给了你一根骨头...)。当操作3D几何时向量可能是唯一最重要的基础概念。三个值(x,y和z)的组合表达了两个重要的值：方向和程度。

图示4.1展示了一个坐标空间的随意选取的点，并且有一个从坐标系统原点指向它的箭头。当我们构造三角形时可以把这个点想成顶点，这个箭头可以想象成向量。首先一个向量，同时也是最简单地，它代表一个从坐标空间原点到点的方向。在OpenGL中我们总是用向量来表示方向量。比如，x轴可以表示为向量(1,0,0)。这个向量说明在x方向上前进一个正单位，在y和z方向上不动。向量还用来表示我们要去哪如何指示--比如，摄像机指向哪个方向，或者我们要逃向哪个方向可以远离鳄鱼。

![figure4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.1.png)

向量在OpenGL操作中是如此的基础性，在GLSL中各种大小的向量是一等类型，并且被赋予名称，比如**vec3**、**vec4**(分别代表三元、四元向量)。

向量可以表达的第二个量是程度。向量的程度是向量的长度。比如x轴向量(1,0,0)，它的长度是1。一个长度为1的向量我们称为*单位向量(unit vector)*。将一个不是单位向量的向量进行缩放为单位向量的过程，我们称为正规化。正规化一个向量使它的长度变为1然后这个向量可以说是正规化过的。当我们只想表达方向而不关心程度时单位向量很重要。同时，如果向量长度出现在我们使用的等式中，那向量的长度为1将会使等式变得简单多！向量的程度也是极重要的，比如，它指示我们应该在某个方向上跑多远
--多远才能远离鳄鱼。

向量和矩阵在3D图形中是如此重要的概念，以至于它们是GLSL(我们编写着色器使用的语言)的一等公民。不过在C++中并不是如此。为了让我们在C++中使用向量和矩阵，本书提供的`vmath`库包含有与GLSL中等价的同名类用来表示向量和矩阵。比如，`vmath::vec3`可以表示一个三分量浮点向量(x,y,z)，`vmath::vec4`可以表示一个四分量浮点向量(x,y,z,w)。*w*坐标添加到向量中使得它变为齐次坐标空间向量，不过它通常设置为1.0。之后x,y和z值可能会被w除，不过当w是1.0时，就不用管了。`vmath`中的类实际上是模板类，可以传递参数实例化为单精度和双精度浮点值，以及带符号整型和非负整型变量。`vmath::vec3`和`vmath::vec4`其实是如下定义：

	typedef Tvec3<float> vec3;
	typedef Tvec4<float> vec4;

声明一个三分量向量：

	vmath::vec3 vVector;

如果我们包含`using namespace vmath;`在源代码中，我们甚至可以写成：

	vec3 vVector;

不过，在本书的例子中，我们总是会在使用`vmath`库时显示带上`vmath::`命名空间。`vmath`中的类都定义了好几个构造函数和拷贝函数，这意味我们可以如下声明和初始化：

	vmath::vec3 vVertex1(0.0f, 0.0f, 1.0f);
	vmath::vec4 vVertex2 = vec4(1.0f, 0.0f, 1.0f, 1.0f);
	vmath::vec4 vVertex3(vVertex1, 1.0f);

现在，一个三个顶点的数组，比如一个三角形，可以声明如下：

	vmath::vec3 vVerts[] = { vmath::vec3(-0.5f, 0.0f, 0.0f),
							 vmath::vec3(0.5f, 0.0f, 0.0f),
							 vmath::vec3(0.0f, 0.5f, 0.0f) };

这看起来很像我们在第二章-“绘制我们的第一个三角形”中的代码。`vmath`库还包含很多数学相关的函数并且覆盖了类的大多数运算子以支持向量和矩阵的加、减、乘、移项等等。

我们也不能太无视第四个分量*w*的存在。大多数时候当我们用顶点位置指定一个几何图形时，三分量的顶点就是我们想要存储和发送给OpenGL的。对很多方向性向量来讲，比如表面法线(surface normal)(一个垂直于表面的向量，用来计算光照)，三分量的向量就足够了。不过，我们马上会深入研究的世界矩阵(world of matrices)，以及变换一个3D顶点，我们就必须要用一个4x4的变换矩阵与它相乘。规则是一个四分量向量我们必须用一个4x4的矩阵来乘。如果我们试图用一个三分量向量和4x4矩阵相乘，那鳄鱼就会吃了我们。如果你想在向量上做自己的矩阵操作，大多数时候你会想要四分量的向量。

### 常规向量运算
向量支持诸多运算，比如加、减、取反，等等。这些运算对每个分量进行计算然后结果是与输入同样大小的向量。`vmath`向量类覆盖了加、减以及取反运算以及其他一些运算。这使得我们可以编写如下代码：

	vmath::vec3 a(1.0f, 2.0f, 3.0f);
	vmath::vec3 b(4.0f, 5.0f, 6.0f);
	vmath::vec3 c;

	c = a + b;
	c = a - b;
	c += b;
	c = -c;

不过向量还有很多操作，我们在接下来的几个小节会从数学角度进行解释。这些操作也同样在`vmath`库中进行了实现。

#### 点积(Dot Product)
向量可以加、减以及缩放，通过简单地分别对xyz分量进行加、减或者缩放。有一个有趣并且有用的操作能且只能应用在两个向量上，那就是*点积(dot product)*，有时候也称为*内积(inner product)*。两个三分量的向量的点积点积得出一个标量(scalar)，这个标量是两个向量夹角的余弦值(cosine)并乘上它们的长度。如果两个向量都是单位长度，则结果位于-1.0到1.0之间，也是它们夹角的余弦值。当然，如果想得到它们真正的夹角，我们还需要取结果的反余弦或者反余切。点积在光照计算中被用到，在漫反射光照计算中两个向量分别是表面法线向量和一个指向光源的向量。在第13章“光照模型”中我们会深入这种类型的着色器代码。图示4.2展示了两个向量，V1和V2，它们的夹角θ表示为。

![figure4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.2.png)

V1和V2的点积可被计算为：

V1 x V2 = V1.<sub>x</sub> x V2.<sub>x</sub> + V1.<sub>y</sub> x V2.<sub>y</sub> + V1.<sub>z</sub> x V2.<sub>z</sub>

`vmath`库中有一些有用的函数使用到点积运算。对于新手可以使用函数`vmath::dot`来计算两个向量的点积，或者使用向量类的成员函数`dot`。

	vmath::vec3 a(...);
	vmath::vec3 b(...);

	float c = a.dot(b);
	float d = vmath::dot(a, b);

使用一个稍微高级一点的函数`vmath::angle`可以获得两个向量夹角的弧度值。

	float angle(const vmath::vec3& u, const vmath::vec3& v);

#### 叉积(Cross Product)
另一个作用于两个向量的数学运算是*叉积(cross product)*，有时又被称为*向量积(vector product)*。叉积的结果是一个新的向量，它垂直于运算的两个向量形成的平面。两个向量V1和V2的叉积可被定义为：

	V1 X V2 = ||V1|| ||V2||sin(θ)n

其中*n*是垂直于V1和V2形成的平面的单位向量。意即如果我们将叉积的结果正规化，那我们就得到了运算平面的法线(normal)。如果V1和V2都是单位长度而且互相垂直，那叉积的结果不需要正规化即为单位长度。图示4.3展示了两个向量V1和V2，以及它们的叉积结果V3。

图示4.3 叉积的结果垂直于运算向量的平面：

![figure4.3](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.3.png)

两个三维向量V1和V2的叉积可被如下计算：

![formula4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.1.png)

再次提醒，`vmath`库中有接收两个向量计算叉积的函数：一个是三分量向量类的成员函数，一个是全局函数。

	vmath::vec3 a(...);
	vmath::vec3 b(...);
	
	vmath::vec3 c = a.cross(b);
	vmath::vec3 d = vmath::cross(a, b);

不比点积，叉积的运算向量的顺序是很重要的。在图示4.3中，V3是V1XV2的结果。如果我们把V1和V2的顺序调换，V3就会指向相反的方向。叉积有很多应用，从三角形表面法线到构造变换矩阵。

#### 向量的长度
正如我们已经讨论过的，向量有方向和程度。向量的程度即是向量的长度。一个三维向量的程度可用如下等式计算：

![formula4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.2.png)

这可以被总结为向量每个分量的平方和的平方根值，向量每个分量的平方和也是一个向量与自身的点积值。在二维空间中，这就是简单的毕达哥拉斯定理：斜边的平方等于其余两边的平方和。这一定理被扩展到任意维度，并且`vmath`库也有相应计算的函数。

	template <typename T, int len>
	static inline T length(const vecN<T,len>& v) { ... }

#### 反射和折射
计算机图形中普遍的运算就是计算反射和折射向量。给定一个入射向量R<sub>in</sub>以及一个表面N的法线，我们希望知道R<sub>in</sub>的反射方向R<sub>reflect</sub>，并且给定一个折射率η的索引，得出R<sub>in</sub>的折射方向。我们在图示4.4中展示这一情况，其中不同值的η对应的折射向量表示为R<sub>refract</sub>,η1到R<sub>refract</sub>,η4。

图示4.4 反射和折射：

![figure4.4](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.4.png)

尽管图示4.4展示的是二维的情形，但我们感兴趣的在三维中的情况(毕竟这是一本3D图形的书)。计算R<sub>reflect</sub>的数学等式为：

R<sub>reflect</sub> = R<sub>in</sub> - (2N · R<sub>in</sub>)N

计算给定η值的R<sub>refract</sub>的数学等式为：

![formula4.3](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.3.png)

要得到预期的结果，R和N都必须是单位向量(意即，它们在被使用之前需正规化处理)。`vmath`中的`reflect()`和`refract()`函数实现了这些等式。

### 矩阵
矩阵(matrix)不仅是一部好莱坞电影三部曲，也是一个异常强大的数学工具，它可以极度简化解决一个或多个等式中变量和其他等式变量有复杂关系的情况。对于图形程序员之心来说近在眼前的这种情况的一个常用示例就是坐标变换。比如，如果我们有一个空间中的点表示为(x,y,z)，我们想知道如果将这个点绕着任意点以任意方向旋转一定角度之后这个点会在哪，我们需要使用矩阵。为什么呢？因为新的x坐标不仅依赖于旧的x坐标和其他旋转参数，还依赖于y和z坐标。这种变量和解决方案之间的依赖仅仅只是矩阵擅长的一类问题。对于电影Matrix的数学爱好者粉丝，“matrix”确实是一个极佳的标题。

在数学上，矩阵无非就是一系列数字以统一的行和列排列好--用编程的行话来说，就是二维数组。矩阵不需要是正方的，但所有行必须有相同数目的元素，所有列必须有相同数目的元素。。如下为一个矩阵，它没有什么特殊意义，这是演示矩阵的结构。

![cookie4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.1.png)

值得提及的是，一个矩阵可以单列或单行的。单行或单列的几个数字可以被更简单地称为我们前面已讨论过的向量。实际上，马上我们就会看到，很多矩阵可以被当做一张列向量的表。

“矩阵”和“向量”是两个重要的专业术语，我们在3D图形编程资料中会经常看到。当处理这些数量时，我们会看到专业术语“标量(scalar)”。一个标量只是一个普通的数字，要来表示一个程度或者一个特殊的数量(你懂的--一个正常的熟悉的、单调的、简单的数字...就像以前一样，让我们把这个行话加到我们的词汇中去)。矩阵可以和其他矩阵相乘或者相加，不过他们也可以和向量或者标量相乘。一个点(用向量表示)乘上一个矩阵(表示一个变换)产生一个变换过的点(另一个向量)。矩阵变换乍看有点可怕但实际上不难理解。因为对矩阵的理解是很多3D任务的基础，所以我们必须试图熟悉它们。幸运的是，只需要一点点的理解就足以让我们前进并且使用OpenGL做很多不可思议的事情。过一阵子，并且通过一些实践和学习，我们就会自己掌握这一数学工具的。

与此同时，就像之前的向量一样，我们会从`vmath`库中找到很多有用的矩阵函数和功能。这个库的源代码在本书的源代码文件夹的`vmath.h`文件中。这个3D数据库极大地简化本章和接下来的任务。这个库的一个“有用的”特性是它没有很聪明的和高度优化的代码！这使得这个库高度可移植而且容易理解。我们还会发现它有恨类似GLSL的语法。

在我们使用OpenGL进行3D编程任务时会用到三种规格的矩阵：2x2，3x3，以及4x4.`vmath`库中有着与GLSL中对应的这些矩阵数据类型，比如：

	vmath::mat2 m1;
	vmath::mat3 m2;
	vmath::mat4 m3;
	
一如GLSL，`vmath`库中的矩阵类定义常用的运算，比如加、减、取反、乘、除，还有构造函数和相关的运算。再次强调，`vmath`库中的矩阵类是使用模板构造的，并且包含有单、双精度浮点数以及有、无符号整型数类型定义。

### 矩阵构造和运算
表示一个4x4的矩阵，OpenGL并不是当做一个浮点数二维数组，而是当成一个16个浮点数一维数组。缺省情况下，OpenGL对矩阵使用列优先或者说是列为主的布局。意即，对于一个4x4的矩阵，前四个元素表示矩阵的第一列，然后四个元素表示矩阵的第二列，以此类推。这种方法与很多数学库不同，大多数数学库都使用二维数组的方式。举个栗子，如下两种表示方式OpenGL会倾向于第一种：

	GLfloat matrix[16];	  // Nice OpenGL-friendly matrix
	GLfloat matrix[4][4];	// Not as convenient for OpenGL programmers
	

OpenGL可以使用第二种变体，但第一种是更高效的表示方式。我们马上就会搞明白这是为什么。16个元素表示4x4的矩阵，如下所示。

![cookie4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.2.png)

当数组中的元素一个接一个地先表示矩阵的列时，我们称这为*列优先(column-major)*矩阵顺序。在主存中，二维数组表示的4x4矩阵(前面代码中的第二种)以*行优先(row-major)*顺序存储。以数学术语来说，两者互为转置矩阵。

在主存中使用列优先表示上述矩阵产生的数组如下：

    static const float A[] = 
    {
        A00, A01, A02, A03, A10, A11, A12, A13,
        A20, A21, A22, A23, A30, A31, A32, A33
    };

相对的，在主存中使用行优先表示上述矩阵为：

    static const float A[] = 
    {
        A00, A10, A20, A30, A01, A11, A21, A31,
        A20, A21, A22, A23, A30, A31, A32, A33
    };

这16个值真正的魔法在于它们可以表示空间的一个特定的位置以及相对观察者在三个坐标轴的一个方位。解释这些数字易如反掌。四个列每个表示一个四元素向量(实际上，`vmath`库在内部用自己的向量类的数组来表示矩阵，其中每个向量表示矩阵的一列)。对于本书来说，为了让事情变得简单，我们只关注前三列的向量的前三个元素。第四列向量包含变换过的坐标系统的原点的x，y和z值。

前三列向量的前三个元素只是方向性向量，它们表示在空间中的x，y，z方位。对于大多数用途来讲，这三个向量总是单位长度(除非我们应用了缩放或者剪切)，而且互成90度。用数学术语来讲(如果你想在朋友面前装逼的话)，当这三个向量互成90度，都是单位长度时，称为标准正交；当不是单位长度时，称为正交。图示4.5展示了一个4x4变换矩阵，其中关心的部分我们高亮了。注意矩阵的最后一行都是0除了最后的元素是1。

图示4.5 一个表示旋转和平移的4x4矩阵：

![figure4.5](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.5.png)

图示4.5中的左上3x3的子矩阵表示一个旋转或者方位。矩阵的最后一列表示一个平移或者位置。

最神奇的事是，如果我们有一个坐标系统内包含有位置和方位的4x4矩阵，然后将一个等价的坐标系统内的顶点(表示为列矩阵或向量)乘上这个4x4矩阵，结果是一个变换到新坐标系统的新顶点。总而言之，空间内的任何位置和任何方位都能使用4x4矩阵唯一定义，并且如果将一个对象的所有顶点都乘上这个矩阵，我们可以将整个对象变换到空间内给定的位置和方位。

另外，如果我们使用一个矩阵将一个对象的顶点从一个空间变换到另一个空间，我们之后可以再用另一个矩阵变换刚才变换过的那些顶点，将它们再次变换到另一个坐标空间。给定矩阵A和B以及向量v，我们知道

    A · (B·v)

等价于

    (A·B)·v

这一关系存在是因为矩阵乘法是*结合性(associative)*的。这里有一个魔法：将所有的变换矩阵进行乘法得到的结果矩阵可以将所有变换堆到一起，然后在最终的乘积中使用结果矩阵。

我们的场景或者对象的最终表现和模型矩阵应用的次序有着重大关系。对于平移和旋转来说尤其如此。我们可以看到矩阵乘法的结合性和*交换性(commutativity)*规则。我们可以用任何我们喜欢的方式将变换的次序群组，因为矩阵乘法是结合性的，但是矩阵在乘法中的次序不能变动，因为矩阵乘法是不具备交换性的。

图示4.6(a)展示了一个正方形先沿z轴旋转然后沿变换后的新x轴平移，图示4.6(b)展示了同样的正方形先先沿x轴平移然后沿z轴旋转。最后两个正方形的布置是不一样的，因为每一个变换都是相对于上一次的变换。在图示4.6(a)中，正方形相对于原点先进行旋转。在图示4.6(b)中，正方形平移后，旋转则是绕着平移后的原点进行旋转。

图示4.6 模型变换：

![figure4.6](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.6.png)
