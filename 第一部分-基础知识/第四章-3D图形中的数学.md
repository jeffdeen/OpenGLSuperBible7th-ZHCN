# 第四章-3D图形中的数学
## 本章我们会学到什么
- 向量是什么，以及为什么我们要关心它们
- 矩阵是什么，以及为什么我们要关心它们
- 我们如何使用矩阵和向量来移动几何图形
- OpenGL约定和坐标空间是什么

到目前为止，我们已经学习了绘制点、线以及三角形，并写过几个简单的着色器传递硬编码的顶点数据。我们还未真正地渲染过3D的内容--在一本3D图形的书中这很奇怪！好吧，要把一系列形状转换到连贯的场景中，我们必须将它们互相以及和视见者安排好。在本章，我们将开始在坐标系统中移动形状和对象。在场景中摆放并设置对象的朝向对于每个3D图形程序员都是重要的能力。我们将会看到，在原点描述好对象的尺寸然后变换到目标位置实际上是很方便的。

## 本章是可怕的数学课吗？
在大多数3D图形编程的书中本章应该就是可怕的数学课了。然而，你可以放轻松，我们会采用比较适度的方式来描述这些原理，而不是干巴巴的文字。

我们的着色器会执行的第一个基础的数学操作就是坐标转换，归结起来就是乘上矩阵和向量。OpenGL程序员用来进行对象和坐标变换的关键是两个矩阵约定。为了让我们熟悉这些矩阵，本章在两种极端的计算机图形哲学中采取折中。一方面，我们可以警告你：“请在阅读本章前去复习下线性代数课本”。另一方面，我们可以欺骗你假装消除你的疑虑，你可以“学习3D图形而丝毫不用关心那些复杂的数学公式”。但我们不赞成任何一个阵营。

实际上，就算你没有非常出色地理解3D图形中的数学，你也可以继续前进，就好像我们每天都开车但不用了解机动车修理和内燃机引擎。但我们最好对车有足够的了解，我们需要常常换油，定期为油箱加油，当轮胎秃了要进行更换。这些知识会让你成为一个负责的、安全的机动车主。如果你像成为一个负责的、有能力的OpenGL程序员，同理。你至少需要懂得基础这样你可以知道什么可以做以及哪个工具最适合工作。如果你是个初学者，你会发现通过一些实践，矩阵数学和向量会逐渐变得易于理解，而且你也会开发出更好的直觉和强大的能力以全面利用本章所介绍的概念。

所以就算你还没有在脑海中将两个矩阵相乘的能力，你也需要知道矩阵是什么，它们如何成为OpenGL 3D魔法的服务手段。不过在我们掸去《线性代数》课本的尘土之前，不要怕：本书的`sb7`库有一个称为`vmath`的组件，它包含有很多有用的类和函数，可以用来表示以及操作向量和矩阵。它们可以直接和OpenGL一起使用，在语法和外观上与GLSL(我们用来编写着色器的语言)神似。所有，我们不需要自己全部来做矩阵和向量的操作，不过知道它们是什么以及如何应用它们仍然是大有裨益的。

## 3D图形数学的一个快速课程
首先，在这里我们不会假设我们会涉及到所有重要的东西。实际上，我们甚至不会涉及到应该知道的所有东西。在本章，我们仅仅会涉及到真正需要知道的东西。如果你已是一个数学能手，你应该立刻跳到后面关于标准3D变换的章节。不仅仅是你已经知道我们会涉及到什么，而且大多数数学迷会觉得不愉快，我们不会给他们喜爱的齐次坐标空间(homogeneous coordinate spaces)功能太多的发挥空间。想象那些真实的TV秀，我们现在必须从一个充满鳄鱼的沼泽中逃出去。知道多少真正需要的3D数学才能生存下来？那就是接下来两节会讲到的--3D数学生存技巧。鳄鱼才不会关心我们是不是真的知道什么是齐次坐标空间。

### 向量(Vector)
OpenGL的主要输入为顶点，顶点有一些属性通常包括位置。最基本的，这是在xyz坐标空间的位置，而且一个给定的位置在这个坐标空间中有且只有一个xyz三元组。一个xyz三元组可以表示为一个向量(实际上，对于纯粹的数学之心来说，一个位置其实也是一个向量--看，我们丢给了你一根骨头...)。当操作3D几何时向量可能是唯一最重要的基础概念。三个值(x,y和z)的组合表达了两个重要的值：方向(direction)和程度(magnitude)。

图示4.1展示了一个坐标空间的随意选取的点，并且有一个从坐标系统原点指向它的箭头。当我们构造三角形时可以把这个点想成顶点，这个箭头可以想象成向量。首先一个向量，同时也是最简单地，它代表一个从坐标空间原点到点的方向。在OpenGL中我们总是用向量来表示方向量。比如，x轴可以表示为向量(1,0,0)。这个向量说明在x方向上前进一个正单位，在y和z方向上不动。向量还用来表示我们要去哪如何指示--比如，摄像机指向哪个方向，或者我们要逃向哪个方向可以远离鳄鱼。

![figure4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.1.png)

向量在OpenGL操作中是如此的基础性，在GLSL中各种大小的向量是一等类型，并且被赋予名称，比如**vec3**、**vec4**(分别代表三元、四元向量)。

向量可以表达的第二个量是程度。向量的程度是向量的长度。比如x轴向量(1,0,0)，它的长度是1。一个长度为1的向量我们称为*单位向量(unit vector)*。将一个不是单位向量的向量进行缩放为单位向量的过程，我们称为正规化。正规化一个向量使它的长度变为1然后这个向量可以说是正规化过的。当我们只想表达方向而不关心程度时单位向量很重要。同时，如果向量长度出现在我们使用的等式中，那向量的长度为1将会使等式变得简单多！向量的程度也是极重要的，比如，它指示我们应该在某个方向上跑多远
--多远才能远离鳄鱼。

向量和矩阵在3D图形中是如此重要的概念，以至于它们是GLSL(我们编写着色器使用的语言)的一等公民。不过在C++中并不是如此。为了让我们在C++中使用向量和矩阵，本书提供的`vmath`库包含有与GLSL中等价的同名类用来表示向量和矩阵。比如，`vmath::vec3`可以表示一个三分量浮点向量(x,y,z)，`vmath::vec4`可以表示一个四分量浮点向量(x,y,z,w)。*w*坐标添加到向量中使得它变为齐次坐标空间向量，不过它通常设置为1.0。之后x,y和z值可能会被w除，不过当w是1.0时，就不用管了。`vmath`中的类实际上是模板类，可以传递参数实例化为单精度和双精度浮点值，以及带符号整型和非负整型变量。`vmath::vec3`和`vmath::vec4`其实是如下定义：

	typedef Tvec3<float> vec3;
	typedef Tvec4<float> vec4;

声明一个三分量向量：

	vmath::vec3 vVector;

如果我们包含`using namespace vmath;`在源代码中，我们甚至可以写成：

	vec3 vVector;

不过，在本书的例子中，我们总是会在使用`vmath`库时显示带上`vmath::`命名空间。`vmath`中的类都定义了好几个构造函数和拷贝函数，这意味我们可以如下声明和初始化：

	vmath::vec3 vVertex1(0.0f, 0.0f, 1.0f);
	vmath::vec4 vVertex2 = vec4(1.0f, 0.0f, 1.0f, 1.0f);
	vmath::vec4 vVertex3(vVertex1, 1.0f);

现在，一个三个顶点的数组，比如一个三角形，可以声明如下：

	vmath::vec3 vVerts[] = { vmath::vec3(-0.5f, 0.0f, 0.0f),
							 vmath::vec3(0.5f, 0.0f, 0.0f),
							 vmath::vec3(0.0f, 0.5f, 0.0f) };

这看起来很像我们在第二章-“绘制我们的第一个三角形”中的代码。`vmath`库还包含很多数学相关的函数并且覆盖了类的大多数运算子以支持向量和矩阵的加、减、乘、移项等等。

我们也不能太无视第四个分量*w*的存在。大多数时候当我们用顶点位置指定一个几何图形时，三分量的顶点就是我们想要存储和发送给OpenGL的。对很多方向性向量来讲，比如表面法线(surface normal)(一个垂直于表面的向量，用来计算光照)，三分量的向量就足够了。不过，我们马上会深入研究的世界矩阵(world of matrices)，以及变换一个3D顶点，我们就必须要用一个4x4的变换矩阵与它相乘。规则是一个四分量向量我们必须用一个4x4的矩阵来乘。如果我们试图用一个三分量向量和4x4矩阵相乘，那鳄鱼就会吃了我们。如果你想在向量上做自己的矩阵操作，大多数时候你会想要四分量的向量。

### 常规向量运算
向量支持诸多运算，比如加、减、取反，等等。这些运算对每个分量进行计算然后结果是与输入同样大小的向量。`vmath`向量类覆盖了加、减以及取反运算以及其他一些运算。这使得我们可以编写如下代码：

	vmath::vec3 a(1.0f, 2.0f, 3.0f);
	vmath::vec3 b(4.0f, 5.0f, 6.0f);
	vmath::vec3 c;

	c = a + b;
	c = a - b;
	c += b;
	c = -c;

不过向量还有很多操作，我们在接下来的几个小节会从数学角度进行解释。这些操作也同样在`vmath`库中进行了实现。

#### 点积(Dot Product)
向量可以加、减以及缩放，通过简单地分别对xyz分量进行加、减或者缩放。有一个有趣并且有用的操作能且只能应用在两个向量上，那就是*点积(dot product)*，有时候也称为*内积(inner product)*。两个三分量的向量的点积点积得出一个标量(scalar)，这个标量是两个向量夹角的余弦值(cosine)并乘上它们的长度。如果两个向量都是单位长度，则结果位于-1.0到1.0之间，也是它们夹角的余弦值。当然，如果想得到它们真正的夹角，我们还需要取结果的反余弦或者反余切。点积在光照计算中被用到，在漫反射光照计算中两个向量分别是表面法线向量和一个指向光源的向量。在第13章“光照模型”中我们会深入这种类型的着色器代码。图示4.2展示了两个向量，V1和V2，它们的夹角θ表示为。

![figure4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.2.png)

V1和V2的点积可被计算为：

V1 x V2 = V1.<sub>x</sub> x V2.<sub>x</sub> + V1.<sub>y</sub> x V2.<sub>y</sub> + V1.<sub>z</sub> x V2.<sub>z</sub>

`vmath`库中有一些有用的函数使用到点积运算。对于新手可以使用函数`vmath::dot`来计算两个向量的点积，或者使用向量类的成员函数`dot`。

	vmath::vec3 a(...);
	vmath::vec3 b(...);

	float c = a.dot(b);
	float d = vmath::dot(a, b);

使用一个稍微高级一点的函数`vmath::angle`可以获得两个向量夹角的弧度值。

	float angle(const vmath::vec3& u, const vmath::vec3& v);

#### 叉积(Cross Product)
另一个作用于两个向量的数学运算是*叉积(cross product)*，有时又被称为*向量积(vector product)*。叉积的结果是一个新的向量，它垂直于运算的两个向量形成的平面。两个向量V1和V2的叉积可被定义为：

	V1 X V2 = ||V1|| ||V2||sin(θ)n

其中*n*是垂直于V1和V2形成的平面的单位向量。意即如果我们将叉积的结果正规化，那我们就得到了运算平面的法线(normal)。如果V1和V2都是单位长度而且互相垂直，那叉积的结果不需要正规化即为单位长度。图示4.3展示了两个向量V1和V2，以及它们的叉积结果V3。

图示4.3 叉积的结果垂直于运算向量的平面：

![figure4.3](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.3.png)

两个三维向量V1和V2的叉积可被如下计算：

![formula4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.1.png)

再次提醒，`vmath`库中有接收两个向量计算叉积的函数：一个是三分量向量类的成员函数，一个是全局函数。

	vmath::vec3 a(...);
	vmath::vec3 b(...);
	
	vmath::vec3 c = a.cross(b);
	vmath::vec3 d = vmath::cross(a, b);

不比点积，叉积的运算向量的顺序是很重要的。在图示4.3中，V3是V1XV2的结果。如果我们把V1和V2的顺序调换，V3就会指向相反的方向。叉积有很多应用，从三角形表面法线到构造变换矩阵。

#### 向量的长度
正如我们已经讨论过的，向量有方向和程度。向量的程度即是向量的长度。一个三维向量的程度可用如下等式计算：

![formula4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.2.png)

这可以被总结为向量每个分量的平方和的平方根值，向量每个分量的平方和也是一个向量与自身的点积值。在二维空间中，这就是简单的毕达哥拉斯定理：斜边的平方等于其余两边的平方和。这一定理被扩展到任意维度，并且`vmath`库也有相应计算的函数。

	template <typename T, int len>
	static inline T length(const vecN<T,len>& v) { ... }

#### 反射和折射
计算机图形中普遍的运算就是计算反射和折射向量。给定一个入射向量R<sub>in</sub>以及一个表面N的法线，我们希望知道R<sub>in</sub>的反射方向R<sub>reflect</sub>，并且给定一个折射率η的索引，得出R<sub>in</sub>的折射方向。我们在图示4.4中展示这一情况，其中不同值的η对应的折射向量表示为R<sub>refract</sub>,η1到R<sub>refract</sub>,η4。

图示4.4 反射和折射：

![figure4.4](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.4.png)

尽管图示4.4展示的是二维的情形，但我们感兴趣的在三维中的情况(毕竟这是一本3D图形的书)。计算R<sub>reflect</sub>的数学等式为：

R<sub>reflect</sub> = R<sub>in</sub> - (2N · R<sub>in</sub>)N

计算给定η值的R<sub>refract</sub>的数学等式为：

![formula4.3](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/formula4.3.png)

要得到预期的结果，R和N都必须是单位向量(意即，它们在被使用之前需正规化处理)。`vmath`中的`reflect()`和`refract()`函数实现了这些等式。

### 矩阵
矩阵(matrix)不仅是一部好莱坞电影三部曲，也是一个异常强大的数学工具，它可以极度简化解决一个或多个等式中变量和其他等式变量有复杂关系的情况。对于图形程序员之心来说近在眼前的这种情况的一个常用示例就是坐标变换。比如，如果我们有一个空间中的点表示为(x,y,z)，我们想知道如果将这个点绕着任意点以任意方向旋转一定角度之后这个点会在哪，我们需要使用矩阵。为什么呢？因为新的x坐标不仅依赖于旧的x坐标和其他旋转参数，还依赖于y和z坐标。这种变量和解决方案之间的依赖仅仅只是矩阵擅长的一类问题。对于电影Matrix的数学爱好者粉丝，“matrix”确实是一个极佳的标题。

在数学上，矩阵无非就是一系列数字以统一的行和列排列好--用编程的行话来说，就是二维数组。矩阵不需要是正方的，但所有行必须有相同数目的元素，所有列必须有相同数目的元素。。如下为一个矩阵，它没有什么特殊意义，这是演示矩阵的结构。

![cookie4.1](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.1.png)

值得提及的是，一个矩阵可以单列或单行的。单行或单列的几个数字可以被更简单地称为我们前面已讨论过的向量。实际上，马上我们就会看到，很多矩阵可以被当做一张列向量的表。

“矩阵”和“向量”是两个重要的专业术语，我们在3D图形编程资料中会经常看到。当处理这些数量时，我们会看到专业术语“标量(scalar)”。一个标量只是一个普通的数字，要来表示一个程度或者一个特殊的数量(你懂的--一个正常的熟悉的、单调的、简单的数字...就像以前一样，让我们把这个行话加到我们的词汇中去)。矩阵可以和其他矩阵相乘或者相加，不过他们也可以和向量或者标量相乘。一个矩阵(表示一个变换)乘上一个点(用向量表示)产生一个变换过的点(另一个向量)。矩阵变换乍看有点可怕但实际上不难理解。因为对矩阵的理解是很多3D任务的基础，所以我们必须试图熟悉它们。幸运的是，只需要一点点的理解就足以让我们前进并且使用OpenGL做很多不可思议的事情。过一阵子，并且通过一些实践和学习，我们就会自己掌握这一数学工具的。

与此同时，就像之前的向量一样，我们会从`vmath`库中找到很多有用的矩阵函数和功能。这个库的源代码在本书的源代码文件夹的`vmath.h`文件中。这个3D数据库极大地简化本章和接下来的任务。这个库的一个“有用的”特性是它没有很聪明的和高度优化的代码！这使得这个库高度可移植而且容易理解。我们还会发现它有恨类似GLSL的语法。

在我们使用OpenGL进行3D编程任务时会用到三种规格的矩阵：2x2，3x3，以及4x4.`vmath`库中有着与GLSL中对应的这些矩阵数据类型，比如：

	vmath::mat2 m1;
	vmath::mat3 m2;
	vmath::mat4 m3;
	
一如GLSL，`vmath`库中的矩阵类定义常用的运算，比如加、减、取反、乘、除，还有构造函数和相关的运算。再次强调，`vmath`库中的矩阵类是使用模板构造的，并且包含有单、双精度浮点数以及有、无符号整型数类型定义。

### 矩阵构造和运算
表示一个4x4的矩阵，OpenGL并不是当做一个浮点数二维数组，而是当成一个16个浮点数一维数组。缺省情况下，OpenGL对矩阵使用列优先或者说是列为主的布局。意即，对于一个4x4的矩阵，前四个元素表示矩阵的第一列，然后四个元素表示矩阵的第二列，以此类推。这种方法与很多数学库不同，大多数数学库都使用二维数组的方式。举个栗子，如下两种表示方式OpenGL会倾向于第一种：

	GLfloat matrix[16];	  // Nice OpenGL-friendly matrix
	GLfloat matrix[4][4];	// Not as convenient for OpenGL programmers
	

OpenGL可以使用第二种变体，但第一种是更高效的表示方式。我们马上就会搞明白这是为什么。16个元素表示4x4的矩阵，如下所示。

![cookie4.2](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.2.png)

当数组中的元素一个接一个地先表示矩阵的列时，我们称这为*列优先(column-major)*矩阵顺序。在主存中，二维数组表示的4x4矩阵(前面代码中的第二种)以*行优先(row-major)*顺序存储。以数学术语来说，两者互为转置矩阵。

在主存中使用列优先表示上述矩阵产生的数组如下：

    static const float A[] = 
    {
        A00, A01, A02, A03, A10, A11, A12, A13,
        A20, A21, A22, A23, A30, A31, A32, A33
    };

相对的，在主存中使用行优先表示上述矩阵为：

    static const float A[] = 
    {
        A00, A10, A20, A30, A01, A11, A21, A31,
        A20, A21, A22, A23, A30, A31, A32, A33
    };

这16个值真正的魔法在于它们可以表示空间的一个特定的位置以及相对视见者在三个坐标轴的一个方位。解释这些数字易如反掌。四个列每个表示一个四元素向量(实际上，`vmath`库在内部用自己的向量类的数组来表示矩阵，其中每个向量表示矩阵的一列)。对于本书来说，为了让事情变得简单，我们只关注前三列的向量的前三个元素。第四列向量包含变换过的坐标系统的原点的x，y和z值。

前三列向量的前三个元素只是方向性向量，它们表示在空间中的x，y，z方位。对于大多数用途来讲，这三个向量总是单位长度(除非我们应用了缩放或者剪切)，而且互成90度。用数学术语来讲(如果你想在朋友面前装逼的话)，当这三个向量互成90度，都是单位长度时，称为标准正交；当不是单位长度时，称为正交。图示4.5展示了一个4x4变换矩阵，其中关心的部分我们高亮了。注意矩阵的最后一行都是0除了最后的元素是1。

图示4.5 一个表示旋转和平移的4x4矩阵：

![figure4.5](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.5.png)

图示4.5中的左上3x3的子矩阵表示一个旋转或者方位。矩阵的最后一列表示一个平移或者位置。

最神奇的事是，如果我们有一个坐标系统内包含有位置和方位的4x4矩阵，然后这个4x4矩阵乘上一个等价的坐标系统内的顶点(表示为列矩阵或向量)，结果是一个变换到新坐标系统的新顶点。总而言之，空间内的任何位置和任何方位都能使用4x4矩阵唯一定义，并且如果这个矩阵乘上一个对象的所有顶点，我们可以将整个对象变换到空间内给定的位置和方位。

另外，如果我们使用一个矩阵将一个对象的顶点从一个空间变换到另一个空间，我们之后可以再用另一个矩阵变换刚才变换过的那些顶点，将它们再次变换到另一个坐标空间。给定矩阵A和B以及向量v，我们知道

    A·(B·v)

等价于

    (A·B)·v

这一关系存在是因为矩阵乘法是*结合性(associative)*的。这里有一个魔法：将所有的变换矩阵进行乘法得到的结果矩阵可以将所有变换堆到一起，然后在最终的乘积中使用结果矩阵。

我们的场景或者对象的最终表现和模型矩阵应用的次序有着重大关系。对于平移和旋转来说尤其如此。我们可以看到矩阵乘法的结合性和*交换性(commutativity)*规则。我们可以用任何我们喜欢的方式将变换的次序群组，因为矩阵乘法是结合性的，但是矩阵在乘法中的次序不能变动，因为矩阵乘法是不具备交换性的。

图示4.6(a)展示了一个正方形先沿z轴旋转然后沿变换后的新x轴平移，图示4.6(b)展示了同样的正方形先先沿x轴平移然后沿z轴旋转。最后两个正方形的布置是不一样的，因为每一个变换都是相对于上一次的变换。在图示4.6(a)中，正方形相对于原点先进行旋转。在图示4.6(b)中，正方形平移后，旋转则是绕着平移后的原点进行旋转。

图示4.6 模型变换：

![figure4.6](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.6.png)

## 理解变换
如果你仔细想想，其实大多数3D图形都不是真正的3D。我们使用3D的概念和术语来描述那些看起来很像3D的东西，然后这些3D的数据被“挤扁”到2D的计算机显示屏幕上。我们将3D数据“挤扁”到2D数据的过程称之为*投影(projection)*。我们描述顶点处理中发生的变换类型(正交-orthographic或者透视-perspective)时会使用投影，不过投影只是OpenGL中发生的变换的一种类型。变换使得我们可以旋转对象、移动对象，甚至拉伸、收缩以及弯曲对象。

### OpenGL的坐标空间
一系列的变换可以使用矩阵来表示，而且与一个矩阵相乘实际上将一个向量从一个坐标空间移动到另一个坐标空间。有几个坐标空间在OpenGL编程中被广泛使用到。在指定顶点到顶点显示到显示屏幕上的这段时间可以发生任意次几何变换，但大多数情况下是模型变换、视见变换和投影。在本章节中，我们对3D计算机图形中常用的坐标空间一一介绍，以及用来将向量在它们间进行移动的变换。

    *坐标空间*             *表示什么*
    模型空间               相对局部原点的位置。有时也称对象空间(object space)。
    
    世界空间               相对全局原点的位置。意即它们在世界中的位置。
    
    视见空间               相对视见者的位置。有时也称摄像机(camera)或者眼睛空间(eye space)。
    
    修剪空间               顶点投影到一个非线性齐次坐标后的位置
    
    标准设备坐标空间        顶点的修剪空间坐标除以各自的w分量之后即为标准设备坐标
    
    窗体空间               相对于窗体原点的顶点像素的位置

将坐标从一个空间移动到另一个空间的矩阵通常用那些空间来命名。比如，将一个对象的顶点从模型空间变换到视见空间的矩阵一般叫做模型-视见矩阵。

#### 对象坐标
通常情况下我们的顶点数据始于对象空间(模型空间)。在对象空间中，顶点的位置是相对于一个局部原点的。考量一个太空船模型。这个模型的原点可能是某个合乎逻辑的地方，比如太空船的鼻尖、重心或者是飞行员坐着的位置。在一个3D建模程式中，回到原点并缩得足够小之后应该将整个太空船展现给我们。一个模型的原点通常可能是我们的旋转点，基于此点旋转调整模型的方向。将原点放置在模型外很远的地方是不合理的，因为这样旋转对象时可能会伴随着很大的平移。

#### 世界坐标
下一个普遍的坐标空间是世界空间。这个空间中的坐标相对于一个固定的、全局的原点。继续拿太空船举例，这个原点可以是一个运动场的中心或者其他固定物体(比如临近的星球)。一旦处于世界空间，所有的对象都置身于一个共有的框架中。通常，光照和物理计算也在这个空间执行。

#### 视见坐标
贯穿本章的一个重要的概念是视见坐标，通常也被称作*摄相机(camera)*或者*眼睛坐标(eye coordinates)*。视见坐标相对于观察者位置(所以才有“摄相机”或者“眼睛”的术语)而不管任何可能发生的变换，我们可以把它们想成“绝对”坐标。所以，眼睛坐标表示一个虚拟的固定坐标系，当成引用的一个共有的框架。图示4.7展示了两个视见点的视见坐标系。

图示4.7 两个视见坐标的透视：

![figure4.7](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.7.png)

左边的视见坐标一如场景观察者所见(意即垂直于监视器)。右边的视见坐标系稍微旋转了一下，这样我们可以更好地看出z轴的关系了。从视见者的角度来看，正向x轴指向右，正向y轴指向上。正向z轴从原点指向用户，负向z轴从视见点指向显示屏幕内。显示屏幕位于z轴0处。

当我们使用OpenGL进行3D绘图时，我们使用笛卡尔坐标系。在没有任何变换的情况下，使用的坐标系与刚才描述的眼睛坐标系无异。

#### 修剪和标准设备空间(NDC)
修剪空间是OpenGL进行修剪的坐标空间。当我们的顶点着色器写入到`gl_Position`，这个坐标就被认为在修剪空间中了。这个坐标也总是一个四维的齐次坐标。在离开修剪空间时，顶点的四个分量都会除以*w*分量。显而易见的是，除完后*w*绝逼会变成1.0。如果在除之前*w*不是1.0，那*x*，*y*和*z*分量就会放大*w*的倒数。这样可以造成透视收缩以及投影的效果。除完后的结果被认为在标准设备空间(NDC)了。很显然，如果一个修剪空间坐标的*w*分量为1.0，那修剪空间和标准设备空间对于这个坐标来说就是等价的。

### 坐标变换
正如前面所述，坐标可以从空间移动到空间，通过将它们的向量表示与*变换矩阵(transformation matrices)*相乘。变换用来操作我们的模型以及它里面特定的对象。这些变换移动对象到特定空间、旋转它们，以及缩放它们。图示4.8展示了三种我们最常会用到的模型变换。图示4.8(a)展示了平移，一个对象沿着给定轴线移动。图示4.8(b)展示了旋转，一个对象绕着轴线旋转。最后图示4.8(c)展示了缩放的效果，对象的大小增长或减少一个特定的量。缩放可以是非统一的(不同的维度可以缩放不同的量)，所以我们可以使用缩放来拉伸或者收缩对象。

图示4.8 模型变换：

![figure4.8](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.8.png)

这些标准变换都可以表示为一个矩阵，我们可以将顶点坐标和这些矩阵相乘来计算出变换后的顶点位置。接下来的几个小节讨论这些矩阵的构造，所有数学和使用到的函数都在`vmath`库中有提供。

#### 单位矩阵
有一些重要类型的变换矩阵在我们使用它们之前先要熟悉一下。第一个就是单位矩阵。如下所示，单位矩阵除了矩阵对角线上是清一色的1.0之外其他都是0.0。4x4的单位矩阵看起来像这样：

![cookie4.3](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.3.png)

一个向量与单位矩阵相乘等价于与1相乘，这没什么卵用。

![cookie4.4](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.4.png)

使用单位矩阵绘制的对象是不会变换的，它们就在原点处(单位矩阵的最后一列)，*x*、*y*和*z*轴与眼睛坐标一样。显而易见的是，2x2，3x3的单位矩阵以及其他维度的单位矩阵都存在并且都是对角线上清一色的1.0。所有的单位矩阵都是正方形的。没有不是正方形的单位矩阵。所有的单位矩阵都是它自己的转置矩阵。我们可以这样用C++生成一个OpenGL可用的单位矩阵：

    // Using a raw array:
    GLfloat m1[] = { 1.0f, 0.0f, 0.0f, 0.0f,     // X Column               0.0f, 1.0f, 0.0f, 0.0f,     // Y Column
                     0.0f, 0.0f, 1.0f, 0.0f,     // Z Column
                     0.0f, 0.0f, 0.0f, 1.0f };   // W Column
                     
    // Or using the vmath::mat4 constructor:
    vmath::mat4 m2 = { 1.0f, 0.0f, 0.0f, 0.0f,     // X Column               0.0f, 1.0f, 0.0f, 0.0f,     // Y Column
                     0.0f, 0.0f, 1.0f, 0.0f,     // Z Column
                     0.0f, 0.0f, 0.0f, 1.0f };   // W Column
                     
`vmath`库中也有为我们构造单位矩阵的便利方法。每个矩阵类都有一个静态成员函数生成一个相应维度的单位矩阵：

    vmath::mat2 m2 = vmath::mat2::identity();
    vmath::mat3 m3 = vmath::mat3::identity();
    vmath::mat4 m4 = vmath::mat4::identity();
    
如果你能回想起来，在第二章的“我们的第一个OpenGL程式”中第一个顶点着色器是一个直通着色器。它不会变换顶点，只是简单地将硬编码的数据以缺省的坐标系原封不动地传递下去。我们本可以将所有顶点与单位矩阵相乘，但这肯定是一个浪费时间、精力毫无意义的操作。

#### 平移矩阵
平移矩阵就是简单地将顶点沿着一个或多个轴线进行移动。图示4.9展示了将一个立方体沿着*y*轴向上移动10个单位。

图示4.9 一个立方体在*y*正方向平移10个单位：

![figure4.9](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.9.png)

4x4平移矩阵的公式如下：

![cookie4.5](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.5.png)

其中，t<sub>x</sub>、t<sub>y</sub>和t<sub>z</sub>分别代表x、y和z轴上的平移。

考查平移矩阵的结构显示出在3D图形中为什么我们要用四维齐次坐标表示位置的一个原因。一个*w*分量为1.0的向量*v*，与上面的平移矩阵相乘得出：

![cookie4.6](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.6.png)

我们可以看到，t<sub>x</sub>、t<sub>y</sub>和t<sub>z</sub>都添加到了v的对应分量上，这样就产生了平移。如果向量*v*的*w*分量不曾为1.0，那使用这个矩阵进行平移就会导致t<sub>x</sub>、t<sub>y</sub>和t<sub>z</sub>被那个值所缩放，最终影响变换的输出结果。在实际应用中，位置向量几乎总是使用*w*分量为1.0的四分量向量来表示，不过方向向量可以用三分量向量或者*w*分量为0的四分量向量。所以一个四分量的方向向量与一个平移矩阵相乘是没什么卵用的。`vmath`库中有两个函数用以创建一个4x4的平移矩阵，可以使用三个分开的参数或者一个3D向量：

    template <typename T>
    static inline Tmat4<T> translate(T x, T y, T z) { ... }
    
    template <typename T>
    static inline Tmat4<T> translate(const vecN<T,3>& v) { ... }
    
#### 旋转矩阵
要将一个对象绕着三个坐标轴或者任意向量进行旋转，那我们需要使用一个旋转矩阵。一个旋转矩阵的形式依赖于我们想要绕着哪个轴旋转。想要绕着x轴旋转，我们使用：

![cookie4.7](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.7.png)

其中，R<sub>x</sub>(θ)表示绕着x轴旋转θ角度。同样，要绕着y或z轴，我们可以使用：

![cookie4.8](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.8.png)

将这三个矩阵相乘得出一个复合变换矩阵是可行的，然后在一次矩阵-向量乘法中分别对三个轴进行给定量的旋转。这样的矩阵像这样：

![cookie4.9](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.9.png)

其中，S<sub>ψ</sub>、S<sub>θ</sub>和S<sub>φ</sub>分别表示ψ、θ和φ的正弦值，C<sub>ψ</sub>、C<sub>θ</sub>和C<sub>φ</sub>分别表示ψ、θ和φ的余弦值。如果这看起来太数学化了，别担心--`vmath`来帮忙：

    template <typename T>
    static inline Tmat4<T> rotate(T angle_x, T angle_y, T angle_z);
    
我们也可以绕着任意轴进行旋转，只要我们将轴向量的x,y,z值指定好。要想看到旋转轴，我们只需要绘制一条从原点到(x,y,z)点的一条线就可以了。`vmath`库也包含有生成角度-轴表示法的旋转矩阵：

    template <typename T>
    static inline Tmat4<T> rotate(T angle, T x, T y, T z);
    
    template <typename T>
    static inline Tmat4<T> rotate(T angle, const vecN<T,3>& axis);
    
这两种`vmath::rotate`函数的重载生成一个旋转矩阵，第一种表示绕着x,y,z指定的轴旋转`angle`度，第二种表示绕着向量*v*旋转`angle`度。其中，我们绕着由x,y,z参数指定的向量进行了旋转。旋转角度是逆时针方向以度进行度量的且由`angle`参数指定。在最简单的情况下，旋转只会绕着坐标系的一个主轴(x,y或者z)进行。

作为示例，如下的代码创建一个旋转矩阵，它将顶点绕着(1,1,1)的轴旋转45°，一如图示4.10刻画的一样。

    vmath::mat4 rotation_matrix = vmath::rotate(45.0, 1.0, 1.0, 1.0);
    
图示4.10：

![figure4.10](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.10.png)

住的注意的是本例中度的应用。这个函数在内部实际上会将度转为弧度，之所以这样定义接口，是因为很多程序员更愿意使用度。

#### 欧拉角(Euler Angles)
欧拉角是用来表示空间中方向的三个角的集合。每个角表示一个旋转，每个旋转绕着我们框架的三个正交向量(比如x,y,z轴)之一进行。我们已经了解到进行矩阵变换时顺序是很重要的，以不同的顺序进行某些变换(比如旋转)会产生不同的结果。这是因为矩阵乘法的不可交换性。所以给定一个欧拉角，我们应该先绕着x轴旋转，然后绕着y，绕后再绕着z还是应该与此相反又或者先绕y轴旋转？好吧，到目前为止我们大可不必烦忧，这不是太要紧。

将方向表示为三个角的集合有一些好处。比如，这种表示法较为直观，这在我们想要将角与用户界面关联起来时很重要。另一个好处就是这样会很容易进行角的插值计算，在一个点上构造一个旋转矩阵，最终的动画就可以看到一个平滑的、连续的运动。不过欧拉角也有一个很严重的缺陷--万向节死锁(gimbal lock)。

当一个角的旋转导致一个轴和另一个轴平行时万向节死锁就发生了。之后绕着现在这两个共轴的任一轴进行旋转都会对模型产生同样的变换，这样便丢失了一个维度的自由。所以欧拉角不适合连接变换或者累积旋转。

译者注：[更多关于万向节死锁的资料](http://www.cnblogs.com/soroman/archive/2008/03/24/1118996.html)。

为避免这种情况的发生，`vmath::roate`函数可以接收一个旋转轴和一个旋转角作为参数。当然，如果我们非要用欧拉角的话，一一指定x,y,z将三个旋转堆叠在一起也是行的，但是使用角-轴的表示方式来进行旋转是更可取的，或者使用*四元组(quaternions)*表示变换并且在必要的时候将它们转换成矩阵。

#### 缩放矩阵
我们最后的“标准”变换矩阵是缩放矩阵。缩放矩阵改变一个对象的大小，这通过扩张或收缩三个轴上的所有点以指定的因子来达成。一个缩放矩阵有如下的形式：

![cookie4.10](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.10.png)

其中，S<sub>x</sub>、S<sub>y</sub>、S<sub>z</sub>分别表示x,y,z维度的缩放因子。使用`vmath`库来创建一个缩放矩阵与创建一个平移或者旋转矩阵的方法类似。有三个函数用来构造缩放矩阵：

    template <typename T>
    static inline Tmat4<T> scale(T x, T y, T z) { ... }
    
    template <typename T>
    static inline Tmat4<T> scale(const Tvec3<T>& v) { ... }
    
    template <typename T>
    static inline Tmat4<T>scale(T x) { ... }
    
第一个函数通过给定的x,y,z参数分别在x,y,z轴上独立地进行缩放。第二个函数和前面的功能一致，只是使用一个三分量向量而不是三个分开的参数来表示缩放因子。第三个函数在三个维度上都进行等量`x`的缩放。缩放并不需要三个维度上统一，我们可以在不同的方向上应用拉伸或者挤压。比如图示4.11中一个10x10x10的立方体可以在x和z方向上缩放。

图示4.11 非统一缩放的立方体：

![figure4.11](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/figure4.11.png)

### 连接变换
我们已经了解到，坐标变换可以表示为矩阵，并且将一个向量从一个空间变换到另一个空间涉及到一次简单的矩阵-向量乘法运算。被一系列矩阵相乘可以应用一系列的变换。没有必要将每次矩阵-向量乘法得出的中间向量保存起来。相比较而言，通常更倾向于先将相关变换的矩阵相乘得出一个可以表示整个变换序列的矩阵。这个矩阵之后可以用来将向量直接从源坐标空间变换到目标坐标空间。记住，顺序是很重要的。当使用`vmath`或者在GLSL中编写代码时，我们总是应该用一个矩阵乘上一个向量并且以相反的顺序解读变换序列。比如，看看下面的代码：

    vmath::mat4 translation_matrix = vmath::translate(4.0f, 10.0f, -20.0f);
    vmath::mat4 rotation_matrix = vmath::rotate(45.0f, vmath::vec3(0.0f, 1.0f, 0.0f));
    vmath::vec4 input_vertex = vmath::vec4(...);
    
    vmath::vec4 transformed_vertex = translation_matrix * 
                                     rotation_matrix *
                                     input_vertex;
                                     
这段代码首先将模型绕y轴旋转45°(因为`rotation_matrix`)自后沿着x轴平移4个单位，沿着y轴平移10个单位，沿着z轴负方向平移20个单位(因为`translation_matrix`)。这些变换将这个模型置于一个特定的方位然后移动到某一位置。反向解读变换序列给出运算的顺序(旋转，然后平移)。我们可以将上面的代码重写如下：

    vmath::mat4 translation_matrix = vmath::translate(4.0f, 10.0f, -20.0f);
    vmath::mat4 rotation_matrix = vmath::rotate(45.0f, vmath::vec3(0.0f, 1.0f, 0.0f));
    vmath::mat4 composite_matrix = translation_matrix * rotation_matrix;
    vmath::vec4 input_vertex = vmath::vec4(...);
    
    vmath::vec4 transformed_vertex = composite_matrix *
                                     input_vertex;
                                     
其中，`composite_matrix`是由平移矩阵乘上旋转矩阵形成的，这样形成了表示旋转然后平移的复合矩阵。这个矩阵之后可以用来变换任意数量的顶点或者其他向量。如果我们有很多顶点要变换，这样可以大大加快计算。每个顶点现在只需要进行一次矩阵-向量乘法运算而不是二次。

这里需要引起注意。很容易与我们编码一样从左到右解读(或写出)变换序列。如果我们按照那样的顺序将平移矩阵和旋转矩阵相乘，那我们就会先移动模型的原点，之后发生的旋转操作就会绕着新的原点，很可能将我们的模型玩坏。

### 四元组(Quaternions)
一个四元组是一个四维量，在某些方面和复数类似。它有一个实体部分和三个虚体部分(类比于复数的一个虚体部分)。一如一个复数有一个虚体部分*i*，一个四元组有三个虚体部分：*i*，*j*，*k*。在数学上一个四元组*q*表示为：

    q = (x + yi + zj + wk)
    
四元组的虚体部分和复数的虚体部分有着类似的性质，特别是：

i<sup>2</sup> = j<sup>2</sup> = k<sup>2</sup> = ikj = -1

同样，i,j,k任两数之积等于另外一数。所以：

    i = jk
    j = ik
    k = ji
    
基于以上我们可以推断出两个四元组乘积如下：

![cookie4.11](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.11.png)

和复数一样，四元组的乘法也是不可交换性的(译者注：复数乘法的交换律在高维度中不再成立)。四元组的加法和减法与简单的向量加减无二，对应的分量加减即可。其他诸如取反和程度(magnitude)和四分量向量表现一致。尽管四元组是四分量的，但在实际中通常用一个标量实体部分和一个三分量向量虚体部分来表示。这种表示法通常写作：

![cookie4.12](https://raw.githubusercontent.com/shawhen/OpenGLSuperBible7th-ZHCN/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/figures/cookie4.12.png)

好啦，很好--但本章不是可怕的数学课不是吗？这里只应该有计算机图形、OpenGL以及其他有趣的东西。对于四元组的准备工作我们就到此为此了。想想我们那接收一个角度和一个旋转轴的旋转函数。我们可以将那两个量表示为一个四元组，把角度填到实体部分，旋转轴填到向量部分，这样便能生成一个四元组表示一个绕任意轴的旋转。

一系列的旋转可以表示为一系列的四元组相乘，生成一个最终的四元组表示所有的旋转。虽然可以制定一串矩阵表示绕着各个笛卡尔轴进行旋转，然后将它们乘在一起，但这种方法容易产生万向节死锁。如果我们用一系列四元组来做同样的事情，将不会发生万向节死锁。为了便于我们编码，`vmath`库包含`vmath::quaternion`类实现了这里描述的大部分功能。

### 模型-视见变换

### 投影变换



